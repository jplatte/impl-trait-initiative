<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Impl trait in type aliases - Impl trait initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../evaluation.html">üî¨ Evaluation</a></li><li class="chapter-item expanded "><a href="../explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit.html">Impl trait in argument types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit_turbofish.html">Turbofish</a></li><li class="chapter-item "><a href="../explainer/apit_traits.html">Traits and impls</a></li></ol></li><li class="chapter-item expanded "><a href="../explainer/tait.html" class="active">Impl trait in type aliases</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/tait_generics.html">Generic parameters</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit.html">Impl trait in return types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/rpit_capture.html">Generic parameter capture</a></li><li class="chapter-item "><a href="../explainer/rpit_names.html">Naming impl trait in return types</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit_trait.html">Return types in trait definitions</a></li><li class="chapter-item "><a href="../explainer/lbit.html">Impl trait in let bindings</a></li><li class="chapter-item "><a href="../explainer/auto_trait.html">Auto traits and impl trait</a></li><li class="chapter-item "><a href="../explainer/inference.html">Appendix A: Inference details</a></li><li class="chapter-item "><a href="../explainer/where_ok.html">Appendix B: Where can impl trait be used</a></li><li class="chapter-item "><a href="../explainer/where_not_ok.html">Appendix C: Where can impl trait NOT be used</a></li><li class="chapter-item "><a href="../explainer/glossary.html">Appendix D: Glossary</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/glossary/defining_scope.html">Defining scope</a></li><li class="chapter-item "><a href="../explainer/glossary/hidden_type.html">Hidden type</a></li></ol></li></ol></li><li class="chapter-item "><a href="../RFC.html">‚ú® RFCs</a></li><li class="chapter-item "><a href="../design-discussions/index.html">üí¨ Design discussions</a></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Impl trait initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/impl-trait" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="impl-trait-in-type-aliases"><a class="header" href="#impl-trait-in-type-aliases">Impl trait in type aliases</a></h1>
<p><strong>Status:</strong> Under active development, <code>type_alias_impl_trait</code> feature gate.</p>
<p>Rust has a concept of <em>type aliases</em>, which let you declare one type name as an alias for another:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Integer = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Type aliases can be useful for giving a short alias for some complex type. For example, imagine we had a module <code>odd</code> that defined an <code>odd_integers</code> function. <code>odd_integers(x, y)</code> returns an iterator over all the odd integers between <code>x</code> and <code>y</code>. Because the full return type is fairly complicated, the module defines a type alias <code>OddIntegers</code> that people can use to refer to it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = std::iter::StepBy&lt;std::ops::Range&lt;u32&gt;&gt;;

    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
        if (start % 2) == 0 {
            start += 1;
        }
        (start..stop).step_by(2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Of course, typing that long type is kind of annoying. Moreover, there are some types in Rust that don't have explicit names. For example, another way to write the &quot;odd integers&quot; iterator would be to call <code>filter</code> with a closure. But if you try to write out the type for that, you'll find that you need to give a name to the type representing the closure itself, which you can't do!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = std::iter::Filter&lt;std::ops::Range&lt;u32&gt;, /* what goes here? */&gt;;

    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
        (start..stop).filter(|x| x % 2 != 0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="enter-impl-traitsup-classfootnote-referencea-hrefparen1asup"><a class="header" href="#enter-impl-traitsup-classfootnote-referencea-hrefparen1asup">Enter impl Trait<sup class="footnote-reference"><a href="#paren">1</a></sup></a></h2>
<div class="footnote-definition" id="paren"><sup class="footnote-definition-label">1</sup>
<p>&quot;He says in parentheses&quot;</p>
</div>
<p>The truth is that specifying the exact type for <code>OddIntegers</code> is overkill anyway. Chances are that we don't actually <em>care</em> what exact type is used there, we only care that <code>odd_integers</code> returns <em>some kind of iterator</em>. In fact, we might <em>prefer</em> not to specify it: that gives us the freedom to change how <code>odd_integers</code> is implemented in the future without potentially affecting our callers. If this sounds familiar, that's good -- it's exactly the kind of scenario that <code>impl Trait</code> is meant to solve!</p>
<p>Using <code>impl Trait</code>, we can still have a type alias <code>OddIntegers</code>, but we can avoid specifying exactly what its value is. Instead, we just say that it is &quot;some iterator over u32&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    //                 ^^^^^^^^^^^^^^^^^^^^^^^^^ :tada:!

    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
        if (start % 2) == 0 {
            start += 1;
        }
        (start..stop).step_by(2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now it's the compiler's job to figure out the value of that type alias. In this case, the type for <code>OddIntegers</code> would be inferred to <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>, but we could also change the definition to use <code>filter</code>, in which case the hidden type would be <code>Filter&lt;Range&lt;u32&gt;, C&gt;</code>, where <code>C</code> represents the type of the closure. This shows something important: the value of an <code>impl Trait</code> can include types that don't otherwise have names (in this case, the closure type <code>C</code>).</p>
<h2 id="hidden-types"><a class="header" href="#hidden-types">Hidden types</a></h2>
<p>You can see that impl trait behaves a bit differently depending on where you use it. What all positions have in common is that they stand in for &quot;some type that implements the given trait&quot;. We call that type the <em>hidden type</em>, because you generally don't get to rely on exactly what it is, you only get to rely on the bounds that it satisfies. What distinguishes the various positions where you can use impl Trait is which code determines the hidden type:</p>
<table><thead><tr><th>Position</th><th>Who determines the hidden type</th></tr></thead><tbody>
<tr><td><a href="./apit.html">Argument position</a></td><td>The caller</td></tr>
<tr><td>Type alias</td><td>Code within the enclosing module</td></tr>
<tr><td>... (full table in <a href="./where_ok.html">Appendix B</a>)</td><td></td></tr>
</tbody></table>
<h2 id="inferring-the-hidden-type"><a class="header" href="#inferring-the-hidden-type">Inferring the hidden type</a></h2>
<p>As the table says, when you use <code>impl Trait</code> in an argument position, the hidden type is determined by the caller of the function (just like other generic parameters). When you use <code>impl Trait</code> in a type alias, the hidden type is inferred based on the code in the enclosing module. We call this enclosing module the <strong>defining scope</strong> for the impl trait. In our example, the defining scope is the module <code>odd</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>As we type-check the functions within the module <code>odd</code> (or its submodules), we look at the ways that they use the type <code>OddIntegers</code>. From this we can derive a set of constraints on what the hidden type has to be. For example, the compiler computes that <code>odd_integers</code> returns a value <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>, but the function is declared to return <code>OddIntegers</code>: therefore we conclude that <code>odd_integers</code> requires the hidden type to be <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>.</p>
<h3 id="there-can-be-multiple-functions-that-constrain-the-type"><a class="header" href="#there-can-be-multiple-functions-that-constrain-the-type">There can be multiple functions that constrain the type</a></h3>
<p>Of course, modules can have more than one function! It's fine to have multiple functions that constrain the type <code>OddIntegers</code>, so long as they all ultimately constrain it to be the same thing. It's also possible to constrain <code>OddIntegers</code> by referencing it in other places. For example, consider the function <code>another_function</code> here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;

    // Requires `OddIntegers` to be `StepBy&lt;Range&lt;u32&gt;&gt;`
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {..}

    // Requires `OddIntegers` to be `StepBy&lt;Range&lt;u32&gt;&gt;`
    fn another_function() {
        let x: OddIntegers = (3..5).step_by(2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>another_function</code> references <code>OddIntegers</code> as the type of the variable <code>x</code> -- but the value assigned to <code>x</code> is also of type <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>, so everything works.</p>
<h3 id="each-function-within-the-defining-scope-must-specify-the-same-type"><a class="header" href="#each-function-within-the-defining-scope-must-specify-the-same-type">Each function within the defining scope must specify the same type</a></h3>
<p>These two functions each independently require that <code>OddIntegers</code> has the same underlying type. What is <em>not</em> ok is to have two functions that require <em>different</em> types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type OddIntegers = impl Iterator&lt;Item = u32&gt;;
//                 ^^^^^^^^^^^^^^^^^^^^^^^^^ :tada:!

fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
    if (start % 2) == 0 {
        start += 1;
    }
    // Requires `OddIntegers` to be `StepBy&lt;Range&lt;u32&gt;&gt;`
    (start..stop).step_by(2)
}

fn another_function() {
    // Requires `OddIntegers` to be `Filter&lt;...&gt;`.
    //
    // ERROR!
    let x: OddIntegers = (3..5).filter(|x| x % 2 != 0);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="each-function-within-the-defining-scope-must-specify-the-complete-type"><a class="header" href="#each-function-within-the-defining-scope-must-specify-the-complete-type">Each function within the defining scope must specify the complete type</a></h3>
<p>Similarly, it is not ok to have functions that only partially constrain and impl Trait. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SomethingDebug = impl Debug;

fn something_debug() -&gt; SomethingDebug {
    // Constrains SomethingDebug to `Option&lt;_&gt;`
    // (where `_` represents &quot;some type yet to be inferred&quot;)
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the <code>something_debug</code> function constrains <code>SomethingDebug</code> to be some sort of <code>Option</code>, but it doesn't say the full type. We only have <code>Option&lt;_&gt;</code>. That's not good enough. You could change this function to specify what kind of option it is, though, and that would be fine:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SomethingDebug = impl Debug;

fn something_debug() -&gt; SomethingDebug {
    // Constrains SomethingDebug to `Option&lt;()&gt;`
    None::&lt;()&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="referencing-the-type-alias-outside-of-the-module"><a class="header" href="#referencing-the-type-alias-outside-of-the-module">Referencing the type alias outside of the module</a></h2>
<p>Since it is declared to be public, the type alias <code>OddIntegers</code> can be referenced from outside the module <code>odd</code>. This allows callers to give a name to the return type of <code>odd_integers</code>:</p>
<pre><pre class="playground"><code class="language-rust">mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers { /* as above */ }
}

fn main() {
    let odds: odd::OddIntegers = odd::odd_integers(1, 10);
    for i in odds {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>Because that code is outside of the defining scope, however, it is not allowed to influence or observe the hidden type. It can only rely on the that were declared<sup class="footnote-reference"><a href="#auto">2</a></sup> (e.g., <code>Iterator&lt;Item = u32&gt;</code>). For example, the following code would not type check:</p>
<div class="footnote-definition" id="auto"><sup class="footnote-definition-label">2</sup>
<p>With the exception of <a href="./auto_trait.html">auto traits</a>.</p>
</div>
<pre><pre class="playground"><code class="language-rust">mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers { /* as above */ }
}

fn main() {
    // Error!
    let odds: std::iter::StepBy&lt;std::iter::Range&lt;u32&gt;&gt; =
        odd::odd_integers(1, 10);
    for i in odds {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>This code fails because <code>odds</code> is not known to have that exact type -- <code>main</code> can only see that <code>odds</code> returns &quot;some kind of iterator&quot;. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../explainer/apit_traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../explainer/tait_generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../explainer/apit_traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../explainer/tait_generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
