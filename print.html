<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Impl trait initiative</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">üëã Welcome</a></li><li class="chapter-item "><a href="CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="evaluation.html">üî¨ Evaluation</a></li><li class="chapter-item "><a href="explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/apit.html">Impl trait in argument types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/apit_turbofish.html">Turbofish</a></li><li class="chapter-item "><a href="explainer/apit_traits.html">Traits and impls</a></li></ol></li><li class="chapter-item "><a href="explainer/tait.html">Impl trait in type aliases</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/tait_infer.html">Inferring the hidden type</a></li><li class="chapter-item "><a href="explainer/tait_ref.html">Referencing from outside the module</a></li><li class="chapter-item "><a href="explainer/tait_generics.html">Generic parameters</a></li></ol></li><li class="chapter-item "><a href="explainer/rpit.html">Impl trait in return types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/rpit_capture.html">Generic parameter capture</a></li><li class="chapter-item "><a href="explainer/rpit_names.html">Naming impl trait in return types</a></li></ol></li><li class="chapter-item "><a href="explainer/rpit_trait.html">Return types in trait definitions</a></li><li class="chapter-item "><a href="explainer/lbit.html">Impl trait in let bindings</a></li><li class="chapter-item "><a href="explainer/auto_trait.html">Auto traits and impl trait</a></li><li class="chapter-item "><a href="explainer/inference.html">Appendix A: Inference details</a></li><li class="chapter-item "><a href="explainer/where_ok.html">Appendix B: Where can impl trait be used</a></li><li class="chapter-item "><a href="explainer/where_not_ok.html">Appendix C: Where can impl trait NOT be used</a></li><li class="chapter-item "><a href="explainer/glossary.html">Appendix D: Glossary</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/glossary/defining_scope.html">Defining scope</a></li><li class="chapter-item "><a href="explainer/glossary/hidden_type.html">Hidden type</a></li></ol></li></ol></li><li class="chapter-item "><a href="RFC.html">‚ú® RFCs</a></li><li class="chapter-item "><a href="design-discussions/index.html">üí¨ Design discussions</a></li><li class="chapter-item "><a href="FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Impl trait initiative</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/impl-trait" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="impl-trait-initiative"><a class="header" href="#impl-trait-initiative">Impl trait initiative</a></h1>
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the Impl trait <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>! To learn more about what we are trying to do, and to find out the people who are doing it, take a look at the <a href="./CHARTER.html">charter</a>. </p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>This is an <strong>umbrella initiative</strong> and, as such, it covers a number of subprojects.</p>
<table><thead><tr><th>Subproject</th><th>Issue</th><th>Progress</th><th>State</th><th><a href="https://lang-team.rust-lang.org/initiatives/process/stages.html">Stage</a></th></tr></thead><tbody>
<tr><td><code>impl Trait</code> in fns and inherent methods</td><td>#123</td><td>‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞</td><td>‚úÖ</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td></tr>
<tr><td>type alias impl trait</td><td><a href="https://github.com/rust-lang/rust/issues/63063">#63063</a></td><td>‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ±‚ñ±</td><td>ü¶Ä</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td></tr>
<tr><td>impl trait in traits, impls</td><td>#123</td><td>‚ñ∞‚ñ∞‚ñ±‚ñ±‚ñ±‚ñ±</td><td>ü¶Ä</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Experimental</a></td></tr>
<tr><td>impl trait in bindings</td><td><a href="https://github.com/rust-lang/rust/issues/63065">#63065</a></td><td>‚ñ∞‚ñ∞‚ñ∞‚ñ±‚ñ±‚ñ±</td><td>üí§</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td></tr>
<tr><td>impl trait with multiple types</td><td></td><td>‚ñ∞‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±</td><td>üí§</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Experimental</a></td></tr>
<tr><td>existential lifetimes</td><td></td><td>‚ñ∞‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±</td><td>üí§</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Experimental</a></td></tr>
</tbody></table>
<p>Key:</p>
<ul>
<li>‚úÖ -- project complete</li>
<li>ü¶Ä -- project in progress</li>
<li>üí§ -- project not under active development</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for 'help wanted' issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-questions/README.html">design questions</a> first. </li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-questions/README.html">design-questions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please [open a &quot;experience report&quot; issue].</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-impl-trait-charter"><a class="header" href="#-impl-trait-charter">üìú Impl trait Charter</a></h1>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>impl-trait is an <strong>umbrella initiative</strong> that is generally developing the <code>impl Trait</code> syntax in Rust. The overall goal is to enable users to write <code>impl Trait</code> to mean &quot;some type implemementing <code>Trait</code>&quot;. We wish to enable this syntax in as many places as it makes sense to do so, and to develop a coherent philosophy around its meaning.</p>
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">Owner</a></td><td><a href="https://github.com/nikomatsakis">nikomatsakis</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">Liaison</a></td><td><a href="https://github.com/ghost">ghost</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-updates"><a class="header" href="#-updates">‚úèÔ∏è Updates</a></h1>
<p>Lang-team initiatives give monthly updates. This section collects the updates from this initiative for posterity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-oct-lang-team-update"><a class="header" href="#2021-oct-lang-team-update">2021-Oct: Lang team update</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>oli-obk completed a rewrite of the inference engine and is in the process of landing it.</li>
<li>oli-obk is also pursuing a rewrite of the region checker to use intersection regions to address some of the shortcomings in the current system.</li>
<li>spastorino wrote a number of test cases covering the &quot;feature surface area&quot;.</li>
<li>spasotrino removed the (incorrectly implemented) support for <code>let x: impl Trait</code>; it will be re-evaluated later.</li>
<li>nikomatsakis is working on an explainer covering the &quot;big picture&quot; of TAITs.</li>
<li>tmandry + nikomatsakis are planning a proposal to permit users to name the types of associated functions from traits or inherent impls.
<ul>
<li>This opens the way for <code>-&gt; impl Trait</code> notation in traits.</li>
</ul>
</li>
</ul>
<h2 id="goals-for-this-month"><a class="header" href="#goals-for-this-month">Goals for this month</a></h2>
<ul>
<li>Prepare stabilization report</li>
<li>Land oli's rewrite</li>
<li>Extend explainer</li>
<li>Extend evaluation doc to cover naming of impl traits</li>
</ul>
<h2 id="questions-for-discussion"><a class="header" href="#questions-for-discussion">Questions for discussion</a></h2>
<ul>
<li>How long should we allow new inference engine to &quot;bake&quot; before stabilizing?
<ul>
<li>We have a large suite of test cases.</li>
<li>The inference engine is used for all impl Trait, including <code>-&gt; impl Trait</code> and <code>async fn</code>, so it gets a lot of testing once it hits stable.</li>
</ul>
</li>
</ul>
<h2 id="type-alias-impl-trait-stabilization"><a class="header" href="#type-alias-impl-trait-stabilization">Type alias impl trait stabilization</a></h2>
<p>The major focus remains &quot;type alias impl trait&quot; (TAIT) stabilization:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Trait;

impl SomeTrait for SomeType {
    type AssocType = impl Debug;

    ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="inference-engine-rewrite"><a class="header" href="#inference-engine-rewrite">Inference engine rewrite</a></h3>
<p>oli-obk has completed a rewrite of the TAIT inference engine so that it matches the inference behavior of the RFC.  This rewrite has been largely completed on a branch and is in the process of landing. It requires a number of supporting changes, such as improvements to NLL diagnostics.</p>
<p>The semantics that were implemented are briefly defined as follows. First, each TAIT has a &quot;defining scope&quot; based on where it appears:</p>
<ul>
<li>In a module-level type alias: the defining scope is the enclosing module.</li>
<li>In the value of an associated type: the defining scope is the impl.</li>
</ul>
<p>Within that defining scope, each item (function, etc) that references the TAIT <em>defines</em> a value for the TAIT based on the results of type-checking. Essentially, the TAIT's value is assumed at first to be an unbound inference variable, and we solve for whatever value of that variable will make the function type check. Each item must completely define the hidden type without relying on other items; further, each item must provide the same value for the hidden type. Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod tait {
    pub type TAIT = impl Debug;

    // `foo` infers TAIT to be `u32`,
    // because that is the value needed
    // to make it type check:
    pub fn foo() {
        let x: TAIT = 22_u32;
    }

    // `get` also infers TAIT to be `u32`,
    // because that is the value needed
    // to make it type check:
    pub fn get() -&gt; TAIT {
        22_u32;
    }

    // `take` also infers TAIT to be `u32`,
    // because that is the value needed
    // to make it type check. Calling `take`
    // from *outside* the module would not
    // be possible except by providing a return
    // value from `get`.
    pub fn take(x: TAIT) {
        let y: u32 = x;
    }

    // Other also constraints TAIT to be `u32`,
    // albeit indirectly.
    pub fn other() {
        take(22_u32);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Outside of the defining scope, references to the type TAIT are opaque. The code is not permitted to rely on the hidden type, though it may peek at the auto traits implemented by the hidden type:</p>
<pre><pre class="playground"><code class="language-rust">mod tait { ... /* as above */ ... }

fn main() {
    // Allowed
    tait::take(tait::get());

    // ERROR-- The hidden type is not visible outside of 
    // the module `tait`, so we can't rely on it being
    // `u32`.
    tait::take(44_u32);

    // ok -- TAIT is an `impl Debug`
    is_debug::&lt;tait::TAIT&gt;(); 

    // ok -- auto traits can rely on the hidden type,
    // and `u32: Send`
    is_send::&lt;tait::TAIT&gt;();

    // error -- even though `u32` implements `Display`,
    // we don't know the hidden type
    is_display::&lt;tait::TAIT&gt;();
}

fn is_send&lt;T: Send&gt;() { }
fn is_debug&lt;T: Debug&gt;() { }
fn is_display&lt;T: Display&gt;() { }
</code></pre></pre>
<h2 id="naming-impl-trait-in-traits"><a class="header" href="#naming-impl-trait-in-traits">Naming impl Trait in traits</a></h2>
<p>We would like to support <code>-&gt; impl Trait</code> in traits and impls. One of the questions that has been blocking progress is the question of how to <em>name</em> the resulting associated type. In other words, the syntax </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar(&amp;self) -&gt; impl Debug + '_;
}
<span class="boring">}
</span></code></pre></pre>
<p>is equivalent to something like this but where <code>Bar</code> is an implicit associated type</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar&lt;'me&gt; = impl Debug + 'me;
    fn bar(&amp;self) -&gt; Self::Bar&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>The problem is that users have no way to name <code>Bar</code>, and hence no way to name the return type of <code>bar</code>. </p>
<p>There have been numerous proposals to address this, but the most straightforward -- and also the most enabling -- seems to be allowing users to get access to the &quot;zero-sized fn type&quot; that represents <code>bar</code>.</p>
<p>The idea would be to define an associated type for every fn item, so that <code>Foo::bar</code> identifies the associated type for this fn in general, and <code>&lt;T as Foo&gt;::bar</code> identifies the associated type for the function as implemented for the type <code>T</code>.</p>
<p>This permits you to access the return type by writing <code>T::bar::Output</code>, for example, although we will have to extend the type checker to accommodate relative associated types like that (the full syntax would be <code>&lt;&lt;T as Foo&gt;::bar as FnOnce&gt;::Output</code>).</p>
<p>These are the known questions to address in the evaluation doc:</p>
<ul>
<li>Can you name top-level functions or other sorts of functions?
<ul>
<li>What about the constructor functions for tuple structs or enum variants?</li>
</ul>
</li>
<li>How to manage associated types and fns with the same name?
<ul>
<li>Do we have an unambiguous syntax such as <code>T::fn(bar)</code> to resolve that?
<ul>
<li>(This might apply to constructor functions as well.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-evaluation"><a class="header" href="#-evaluation">üî¨ Evaluation</a></h1>
<blockquote>
<p>The <em>evaluation</em> surveys the various design approaches that are under consideration.
It is not required for all initiatives, only those that begin with a problem statement
but without a clear picture of the best solution. Often the evaluation will refer to topics
in the <a href="./design-discussions.html">design-discussions</a> for more detailed consideration.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-explainer"><a class="header" href="#-explainer">üìö Explainer</a></h1>
<blockquote>
<p>The &quot;explainer&quot; is &quot;end-user readable&quot; documentation that explains how to use the feature being developed by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the explainer should be considered a work-in-progress.</p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This explainer describes the &quot;impl Trait&quot; feature as a complete unit. However, not all parts of this story are in the same state. Some parts are available on stable, others are available on nightly, others have accepted RFCs but are not yet implemented, and still others are in the exploration phase. Each section of the explainer has a &quot;status&quot; tag that indicates whether the status of that particular content.</p>
<h2 id="impl-trait-make-the-compiler-do-the-hard-work-of-figuring-out-the-exact-type"><a class="header" href="#impl-trait-make-the-compiler-do-the-hard-work-of-figuring-out-the-exact-type">Impl trait: make the compiler do the hard work of figuring out the exact type</a></h2>
<p><strong>Status:</strong> Stable</p>
<p>Oftentimes, you have a situation where you don't care <em>exactly</em> what type something has, you simply care that it implements particular traits. For example, you might have a function that accepts any kind of iterator as long as it produces integers. In this case, you could write the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_integers(integers: impl Iterator&lt;Item = u32&gt;) -&gt; u32 {
    //                    ^^^^^^^^^^^^^
    let mut sum = 0;
    for integer in integers {
        sum += x;
    }
    sum
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the <code>impl Iterator</code> type is a special sort of type. It doesn't actually name any particular type. Instead, it is a <em>shorthand</em> for a <em>generic type</em>. In other words, the function above is roughly equivalent to the following desugared version:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_integers&lt;I&gt;(integers: I) -&gt; u32
where
    I: Integers&lt;Item = u32&gt;
{
    let mut sum = 0;
    for integer in integers {
        sum += x;
    }
    sum
}
<span class="boring">}
</span></code></pre></pre>
<p>Intuitively, a function that has an argument of type <code>impl Iterator</code> is saying &quot;you can give me any sort of iterator that you like&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-argument-types"><a class="header" href="#impl-trait-in-argument-types">Impl trait in argument types</a></h1>
<p><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></p>
<p>When you use an <code>impl Trait</code> in the type of a function argument, that is generally equivalent to adding a generic parameter to the function.
So this function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_integers(integers: impl Iterator&lt;Item = u32&gt;) -&gt; u32 {
    //                    ^^^^^^^^^^^^^
    let mut sum = 0;
    for integer in integers {
        sum += x;
    }
    sum
}
<span class="boring">}
</span></code></pre></pre>
<p>is roughly equivalent to the following generic function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_integers&lt;I&gt;(integers: I) -&gt; u32
where
    I: Integers&lt;Item = u32&gt;
{
    let mut sum = 0;
    for integer in integers {
        sum += x;
    }
    sum
}
<span class="boring">}
</span></code></pre></pre>
<p>Intuitively, a function that has an argument of type <code>impl Iterator</code> is saying &quot;you can give me any sort of iterator that you like&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turbofish"><a class="header" href="#turbofish">Turbofish</a></h1>
<p><img src="https://img.shields.io/badge/status-needs%20decision-informational" alt="needs decision" /></p>
<p>Using <code>impl Trait</code> in argument position conceptually adds a generic parameter to the function. However, this generic parameter is different from explicit, named parameters. Its value cannot be specified explicitly using the turbofish operator, and must be inferred. Therefore, these two functions behave in slightly different ways:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo1(x: impl Clone) { }
fn foo2&lt;C: Clone&gt;(x: C) { }
<span class="boring">}
</span></code></pre></pre>
<p>The difference is that one can write <code>foo2::&lt;i32&gt;</code> to manually specify the value of the <code>C</code> parameter, but the value of the <code>impl Clone</code> parameter on <code>foo1</code> must be inferred from the argument types that are supplied (e.g, <code>foo1(22)</code>).</p>
<p>It is possible to mix explicit generics with impl Trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo3&lt;A: Debug&gt;(x: A, b: impl Clone) { }
<span class="boring">}
</span></code></pre></pre>
<p>In this case, one can use turbofish to specify the value of <code>A</code>, but not the <code>impl Clone</code>. In other words, one could write <code>foo3::&lt;i32&gt;</code> to get a function where <code>A</code> is specified as <code>i32</code>, but the value of <code>impl Clone</code> will still have to be inferred from usage.</p>
<p><strong>Implication.</strong> The fact that impl trait and explicit generics are not equivalent means that one cannot migrate between them in a semver-compliant way, although breakage is quite unusual in practice.</p>
<p><strong>Implementation note:</strong> This section describes the &quot;recommended&quot; behavior that we expect to propose to the lang team. The currently implemented semantics are different. They forbid turbofish from being used on any function that employs argument position impl trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-and-impls"><a class="header" href="#traits-and-impls">Traits and impls</a></h1>
<p><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></p>
<p>You can use <code>impl Trait</code> in argument position in traits and impls, but you must use it consistently in both. For example, the following is legal:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Operation {
    fn compute(x: impl Iterator&lt;Item = u32&gt;) -&gt; u32;
}

Struct Sum;
impl Operation for Sum {
    fn compute(x: impl Iterator&lt;Item = u32&gt;) -&gt; u32 {
        x.sum()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>But the following would be illegal:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Max;
impl Operation for Sum {
    fn compute&lt;I: Iterator&lt;Item = u32&gt;&gt;(x: I) -&gt; u32 {
        x.max()
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-type-aliases"><a class="header" href="#impl-trait-in-type-aliases">Impl trait in type aliases</a></h1>
<p><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /></p>
<p>Rust has a concept of <em>type aliases</em>, which let you declare one type name as an alias for another:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Integer = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Type aliases can be useful for giving a short alias for some complex type. For example, imagine we had a module <code>odd</code> that defined an <code>odd_integers</code> function. <code>odd_integers(x, y)</code> returns an iterator over all the odd integers between <code>x</code> and <code>y</code>. Because the full return type is fairly complicated, the module defines a type alias <code>OddIntegers</code> that people can use to refer to it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = std::iter::StepBy&lt;std::ops::Range&lt;u32&gt;&gt;;

    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
        if (start % 2) == 0 {
            start += 1;
        }
        (start..stop).step_by(2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Of course, typing that long type is kind of annoying. Moreover, there are some types in Rust that don't have explicit names. For example, another way to write the &quot;odd integers&quot; iterator would be to call <code>filter</code> with a closure. But if you try to write out the type for that, you'll find that you need to give a name to the type representing the closure itself, which you can't do!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = std::iter::Filter&lt;std::ops::Range&lt;u32&gt;, /* what goes here? */&gt;;

    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
        (start..stop).filter(|x| x % 2 != 0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="enter-impl-traitsup-classfootnote-referencea-hrefparen1asup"><a class="header" href="#enter-impl-traitsup-classfootnote-referencea-hrefparen1asup">Enter impl Trait<sup class="footnote-reference"><a href="#paren">1</a></sup></a></h2>
<div class="footnote-definition" id="paren"><sup class="footnote-definition-label">1</sup>
<p>&quot;He says in parentheses&quot;</p>
</div>
<p>The truth is that specifying the exact type for <code>OddIntegers</code> is overkill anyway. Chances are that we don't actually <em>care</em> what exact type is used there, we only care that <code>odd_integers</code> returns <em>some kind of iterator</em>. In fact, we might <em>prefer</em> not to specify it: that gives us the freedom to change how <code>odd_integers</code> is implemented in the future without potentially affecting our callers. If this sounds familiar, that's good -- it's exactly the kind of scenario that <code>impl Trait</code> is meant to solve!</p>
<p>Using <code>impl Trait</code>, we can still have a type alias <code>OddIntegers</code>, but we can avoid specifying exactly what its value is. Instead, we just say that it is &quot;some iterator over u32&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    //                 ^^^^^^^^^^^^^^^^^^^^^^^^^ :tada:!

    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
        if (start % 2) == 0 {
            start += 1;
        }
        (start..stop).step_by(2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now it's the compiler's job to figure out the value of that type alias. In this case, the type for <code>OddIntegers</code> would be inferred to <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>, but we could also change the definition to use <code>filter</code>, in which case the hidden type would be <code>Filter&lt;Range&lt;u32&gt;, C&gt;</code>, where <code>C</code> represents the type of the closure. This shows something important: the value of an <code>impl Trait</code> can include types that don't otherwise have names (in this case, the closure type <code>C</code>).</p>
<h2 id="hidden-types"><a class="header" href="#hidden-types">Hidden types</a></h2>
<p>You can see that impl trait behaves a bit differently depending on where you use it. What all positions have in common is that they stand in for &quot;some type that implements the given trait&quot;. We call that type the <em>hidden type</em>, because you generally don't get to rely on exactly what it is, you only get to rely on the bounds that it satisfies. What distinguishes the various positions where you can use impl Trait is which code determines the hidden type:</p>
<table><thead><tr><th>Position</th><th>Who determines the hidden type</th></tr></thead><tbody>
<tr><td><a href="explainer/./apit.html">Argument position</a></td><td>The caller</td></tr>
<tr><td>Type alias</td><td>Code within the enclosing module</td></tr>
<tr><td>... (full table in <a href="explainer/./where_ok.html">Appendix B</a>)</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferring-the-hidden-type"><a class="header" href="#inferring-the-hidden-type">Inferring the hidden type</a></h1>
<p><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /></p>
<p>When you use <code>impl Trait</code> in a type alias, the hidden type is inferred based on the code in the enclosing module. We call this enclosing module the <strong>defining scope</strong> for the impl trait. In our example, the defining scope is the module <code>odd</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>As we type-check the functions within the module <code>odd</code> (or its submodules), we look at the ways that they use the type <code>OddIntegers</code>. From this we can derive a set of constraints on what the hidden type has to be. For example, the compiler computes that <code>odd_integers</code> returns a value <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>, but the function is declared to return <code>OddIntegers</code>: therefore we conclude that <code>odd_integers</code> requires the hidden type to be <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>.</p>
<h2 id="there-can-be-multiple-functions-that-constrain-the-type"><a class="header" href="#there-can-be-multiple-functions-that-constrain-the-type">There can be multiple functions that constrain the type</a></h2>
<p>Of course, modules can have more than one function! It's fine to have multiple functions that constrain the type <code>OddIntegers</code>, so long as they all ultimately constrain it to be the same thing. It's also possible to constrain <code>OddIntegers</code> by referencing it in other places. For example, consider the function <code>another_function</code> here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;

    // Requires `OddIntegers` to be `StepBy&lt;Range&lt;u32&gt;&gt;`
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {..}

    // Requires `OddIntegers` to be `StepBy&lt;Range&lt;u32&gt;&gt;`
    fn another_function() {
        let x: OddIntegers = (3..5).step_by(2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>another_function</code> references <code>OddIntegers</code> as the type of the variable <code>x</code> -- but the value assigned to <code>x</code> is also of type <code>StepBy&lt;Range&lt;u32&gt;&gt;</code>, so everything works.</p>
<h2 id="each-function-within-the-defining-scope-must-specify-the-same-type"><a class="header" href="#each-function-within-the-defining-scope-must-specify-the-same-type">Each function within the defining scope must specify the same type</a></h2>
<p>These two functions each independently require that <code>OddIntegers</code> has the same underlying type. What is <em>not</em> ok is to have two functions that require <em>different</em> types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type OddIntegers = impl Iterator&lt;Item = u32&gt;;
//                 ^^^^^^^^^^^^^^^^^^^^^^^^^ :tada:!

fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers {
    if (start % 2) == 0 {
        start += 1;
    }
    // Requires `OddIntegers` to be `StepBy&lt;Range&lt;u32&gt;&gt;`
    (start..stop).step_by(2)
}

fn another_function() {
    // Requires `OddIntegers` to be `Filter&lt;...&gt;`.
    //
    // ERROR!
    let x: OddIntegers = (3..5).filter(|x| x % 2 != 0);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="each-function-within-the-defining-scope-must-specify-the-complete-type"><a class="header" href="#each-function-within-the-defining-scope-must-specify-the-complete-type">Each function within the defining scope must specify the complete type</a></h2>
<p>Similarly, it is not ok to have functions that only partially constrain and impl Trait. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SomethingDebug = impl Debug;

fn something_debug() -&gt; SomethingDebug {
    // Constrains SomethingDebug to `Option&lt;_&gt;`
    // (where `_` represents &quot;some type yet to be inferred&quot;)
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the <code>something_debug</code> function constrains <code>SomethingDebug</code> to be some sort of <code>Option</code>, but it doesn't say the full type. We only have <code>Option&lt;_&gt;</code>. That's not good enough. You could change this function to specify what kind of option it is, though, and that would be fine:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SomethingDebug = impl Debug;

fn something_debug() -&gt; SomethingDebug {
    // Constrains SomethingDebug to `Option&lt;()&gt;`
    None::&lt;()&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencing-the-type-alias-outside-of-the-module"><a class="header" href="#referencing-the-type-alias-outside-of-the-module">Referencing the type alias outside of the module</a></h1>
<p><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /></p>
<p>Since it is declared to be public, the type alias <code>OddIntegers</code> can be referenced from outside the module <code>odd</code>. This allows callers to give a name to the return type of <code>odd_integers</code>:</p>
<pre><pre class="playground"><code class="language-rust">mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers { /* as above */ }
}

fn main() {
    let odds: odd::OddIntegers = odd::odd_integers(1, 10);
    for i in odds {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>Because that code is outside of the defining scope, however, it is not allowed to influence or observe the hidden type. It can only rely on the that were declared<sup class="footnote-reference"><a href="#auto">1</a></sup> (e.g., <code>Iterator&lt;Item = u32&gt;</code>). For example, the following code would not type check:</p>
<div class="footnote-definition" id="auto"><sup class="footnote-definition-label">1</sup>
<p>With the exception of <a href="explainer/./auto_trait.html">auto traits</a>.</p>
</div>
<pre><pre class="playground"><code class="language-rust">mod odd {
    pub type OddIntegers = impl Iterator&lt;Item = u32&gt;;
    pub fn odd_integers(mut start: u32, stop: u32) -&gt; OddIntegers { /* as above */ }
}

fn main() {
    // Error!
    let odds: std::iter::StepBy&lt;std::iter::Range&lt;u32&gt;&gt; =
        odd::odd_integers(1, 10);
    for i in odds {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>This code fails because <code>odds</code> is not known to have that exact type -- <code>main</code> can only see that <code>odds</code> returns &quot;some kind of iterator&quot;. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-parameters-and-type-alias-impl-trait"><a class="header" href="#generic-parameters-and-type-alias-impl-trait">Generic parameters and type alias impl trait</a></h1>
<p>![nightly][]
[planning rfc]: https://img.shields.io/badge/status-draft%20rfc-informational
[accepted rfc]: https://img.shields.io/badge/status-accepted%20rfc-informational
[needs decision]: https://img.shields.io/badge/status-needs%20decision-informational
[stable]: https://img.shields.io/badge/status-stable-success
[nightly]: https://img.shields.io/badge/status-nightly-important
[may-change]: https://img.shields.io/badge/warning-implementation%20may%20change-critical</p>
<p>Type alias impl Traits can also be generic:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SomeTupleIterator&lt;I, J&gt; = impl Iterator&lt;Item = (I, J)&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>The values that you use for these generic parameters, however, are subject to some restrictions. In particular, type aliases can only be used with other generic types that are in scope, and each parameter must be distinct. Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo1&lt;A, B&gt;() -&gt; SomeTupleIterator&lt;A, B&gt; { /* ok */ }
fn foo2&lt;A, B&gt;() -&gt; SomeTupleIterator&lt;B, A&gt; { /* ok */ }
fn foo3&lt;A, B&gt;() -&gt; SomeTupleIterator&lt;A, A&gt; { /* not ok -- same parameter used twice */ }
fn foo4&lt;A, B&gt;() -&gt; SomeTupleIterator&lt;A, u32&gt; { /* not ok -- u32 is not a type parameter */ }
<span class="boring">}
</span></code></pre></pre>
<p>These rules ensure that inference is tractable. Consider the case of <code>-&gt; SomeTupleIterator&lt;A, u32&gt;</code>. Imagine that <code>foo4</code> returned an iterator over <code>(A, u32)</code> tuples. How do we translate that value to the hidden type for <code>SomeTupleIterator</code>?  There would actually be multiple possibilities. Either it would be an iterator over <code>(I, J)</code> (with <code>I = A</code> and <code>J = u32</code> in this case), or an iterator over <code>(I, u32)</code> (with <code>I = A</code> and <code>J</code> unused).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-return-types"><a class="header" href="#impl-trait-in-return-types">Impl trait in return types</a></h1>
<p><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></p>
<p>In the section on <a href="explainer/./tait.html">type aliases</a>, we gave the example of a function <code>odd_integers</code> that returned a type alias <code>OddIntegers</code>. If you prefer, you can forego defining the type alias and simply return an <code>impl Trait</code> directly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn odd_integers(start: u32, stop: u32) -&gt; impl Iterator&lt;Item = u32&gt; {
    (start..stop).filter(|i| i % 2 == 0)
}
<span class="boring">}
</span></code></pre></pre>
<p>This is <em>almost</em> equivalent to the type alias we saw before, but there are two differences:</p>
<ul>
<li>The <strong>defining scope</strong> for the impl trait is just the function <code>odd_integers</code>, and not the enclosing module.
<ul>
<li>This means that other functions within the same module cannot observe or constrain the hidden type.</li>
</ul>
</li>
<li>There is no direct way to name the resulting type (because you didn't define a type alias).
<ul>
<li>But see the section on <a href="explainer/./rpit_naming.html">naming impl trait in return type</a> for indirect techniques.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-parameter-capture"><a class="header" href="#generic-parameter-capture">Generic parameter capture</a></h1>
<p><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></p>
<p>When you use an impl trait in return position, there are some limitations on the &quot;hidden type&quot; that may be used. </p>
<p>XXX document:</p>
<ul>
<li>you can capture type parameters</li>
<li>but not lifetimes, unless they appear in the bounds</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naming-impl-trait-in-return-types"><a class="header" href="#naming-impl-trait-in-return-types">Naming impl trait in return types</a></h1>
<p><img src="https://img.shields.io/badge/status-draft%20rfc-informational" alt="planning rfc" /></p>
<p>Return position impl Trait introduces types that do not have proper names. If you find yourself frequently giving that type a name, your best bet is to introduce a type alias. However, in a pinch, it is possible to access those types by getting the type for the surrounding function and extracting its <code>FnOnce::Output</code> associated type. Given a function like...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_iter() -&gt; impl Iterator&lt;Item = u32&gt; {
    0 .. 100
}
<span class="boring">}
</span></code></pre></pre>
<p>...one could use the type <code>make_iter::Output</code> to access the inferred <code>impl Iterator</code> (which will be a <code>Range&lt;u32&gt;</code>, in this case).</p>
<p>Function types can generally be named via their path:</p>
<ul>
<li>For function items, simply the name of the function (<code>fn_name</code>)</li>
<li>For inherent methods, the fully qualified syntax of <code>Type::fn_name</code></li>
<li>For trait methods defined in an impl, use the fully qualified syntax <code>&lt;Type as Trait&gt;::fn_name</code> (as if <code>fn_name</code> were an associated type)</li>
</ul>
<p>In each case, the type for the function is a zero-sized type that implements the <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> traits. This type is considered to be defined in its surrounding module and it is also possible to use it in other contexts, such as to implement the <code>Default</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; u32 { 22 }

impl Default for foo {
    fn default() -&gt; Self {
        foo
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-types-in-trait-definitions-and-impls"><a class="header" href="#return-types-in-trait-definitions-and-impls">Return types in trait definitions and impls</a></h1>
<p><img src="https://img.shields.io/badge/status-draft%20rfc-informational" alt="planning rfc" /></p>
<p>When you use <code>impl Trait</code> as the return type for a function within a trait definition or trait impl, the semantics are somewhat different than in other cases. Consider the following trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIntIterator {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>The semantics of this are analogous to introducing a new associated type within the surrounding trait;</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIntIterator { // desugared
    type IntoIntIter: Iterator&lt;Item = u32&gt;;
    fn into_int_iter(self) -&gt; Self::IntoIntIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>(In general, this associated type may be generic; it would contain whatever generic parameters are captured per the generic capture rules given previously.)</p>
<p>This associated type is introduced by the compiler and cannot be named by users.</p>
<p>The impl for a trait like <code>IntoIntIterator</code> must also use <code>impl Trait</code> in return position:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIntIterator for Vec&lt;u32&gt; {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        self.into_iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is equivalent to specify the value of the associated type as an <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIntIterator for Vec&lt;u32&gt; {
    type IntoIntIter = impl Iterator&lt;Item = u32&gt;
    fn into_int_iter(self) -&gt; Self::IntoIntIter {
        self.into_iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-let-bindings"><a class="header" href="#impl-trait-in-let-bindings">Impl trait in let bindings</a></h1>
<p><img src="https://img.shields.io/badge/status-accepted%20rfc-informational" alt="accepted rfc" /></p>
<p>You can also use <code>impl Trait</code> in the type of a local variable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: impl Clone = 22_i32;
<span class="boring">}
</span></code></pre></pre>
<p>This is equivalent to introducing a type alias impl trait with the scope of the enclosing function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type X = impl Clone;
let x: X = 22_i32;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-traits-and-impl-trait"><a class="header" href="#auto-traits-and-impl-trait">Auto traits and impl trait</a></h1>
<p><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></p>
<p>When talking about output impl Traits in the previous section, we said that callers cannot rely on the precise hidden type, but must instead rely only on the declared bounds from the impl Trait. This was actually a simplification: in reality, callers are able to rely on <em>some</em> aspects of the hidden type. Specifically, they are able to deduce whether the hidden type implements the various <a href="https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits">auto traits</a>, like <code>Send</code> and <code>Sync</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn odd_integers(start: u32, stop: u32) -&gt; impl Iterator&lt;Item = u32&gt; {
    (start..stop).filter(|i| i % 2 == 0)
}

fn other_function() {
    let integers = odd_integers();

    // This requires that `integers` is `Send`.
    // The compiler &quot;peeks&quot; at the hidden type
    // to check that this is true.
    std::thread::spawn(move || {
        for integer in integers {
            println!(&quot;{}&quot;, integer);
        }
    }).join();
}
<span class="boring">}
</span></code></pre></pre>
<p>The motivation behind auto trait leakage is that it makes working with <code>impl Trait</code> as convenient as other kinds of &quot;newtype wrappers&quot; when it comes to threading. For example, if you were to replace the <code>odd_integers</code> return type with a newtype <code>OddIntegers</code> that hides the iterator type (as is common practice)...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OddIntegers {
    iterator: Filter&lt;Range&lt;...&gt;, ...&gt;
}

fn odd_integers(start: u32, stop: u32) -&gt; OddIntegers { ... }
<span class="boring">}
</span></code></pre></pre>
<p>...you would find that <code>OddIntegers</code> implements <code>Send</code> if that hidden type (that appears in its private field) implements <code>Send</code>. (In this particular case, it would be challenging to create a struct because it would have to refer to the returned closure type, which is anonymous.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-inference-details"><a class="header" href="#appendix-a-inference-details">Appendix A: Inference details</a></h1>
<p><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /></p>
<p>The process to infer the hidden type for an impl Trait is as follows.</p>
<ul>
<li>When type-checking functions or code within the <em>defining scope</em> of an impl Trait <code>X</code>:
<ul>
<li>Accumulate subtyping constraints from type check:
<ul>
<li>For example, <code>let var: X = 22_i32</code> would create the subtyping constraint that <code>i32</code> is a subtype of <code>X</code>.</li>
<li>Similarly, given <code>fn foo() -&gt; X</code>, <code>let var: i32 = foo()</code> wold create the subtyping constraint that <code>X</code> be a subtype of <code>i32</code>.</li>
</ul>
</li>
<li>The type <code>X</code> is assumed to implement the traits that appear in its bounds
<ul>
<li>Exception: auto traits. Proving an auto trait <code>X: Send</code> is done by &quot;revealing&quot; the hidden type and proving the auto trait against the hidden type.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-where-can-impl-trait-be-used"><a class="header" href="#appendix-b-where-can-impl-trait-be-used">Appendix B: Where can impl trait be used</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>We can now extend the table of impl trait positions introduced in the <a href="explainer/./tait.html">type alias</a> chapter with an additional entry:</p>
<table><thead><tr><th>Position</th><th>Who determines the hidden type</th><th>Status</th></tr></thead><tbody>
<tr><td><a href="explainer/./apit.html">Argument position</a></td><td>Each caller</td><td><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></td></tr>
<tr><td><a href="explainer/./tait.html">Type alias</a></td><td>Code within the enclosing module</td><td><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /></td></tr>
<tr><td><a href="explainer/./rpit.html">Return position, free fns</a></td><td>The function body</td><td><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></td></tr>
<tr><td><a href="explainer/./rpit.html">Return position, inherent impls</a></td><td>The function body</td><td><img src="https://img.shields.io/badge/status-stable-success" alt="stable" /></td></tr>
<tr><td><a href="explainer/./rpit.html">Return position, trait impls</a></td><td>The function body</td><td><img src="https://img.shields.io/badge/status-draft%20rfc-informational" alt="planning rfc" /></td></tr>
<tr><td><a href="explainer/./rpit_trait.html">Return position, traits</a></td><td>The impl</td><td><img src="https://img.shields.io/badge/status-draft%20rfc-informational" alt="planning rfc" /></td></tr>
<tr><td><a href="explainer/./lbit.html">Let binding</a></td><td>The enclosing function or code block</td><td><img src="https://img.shields.io/badge/status-accepted%20rfc-informational" alt="accepted rfc" /></td></tr>
<tr><td><a href="explainer/./lbit.html">Const binding</a></td><td>The const initializer</td><td><img src="https://img.shields.io/badge/status-accepted%20rfc-informational" alt="accepted rfc" /></td></tr>
<tr><td><a href="explainer/./lbit.html">Static binding</a></td><td>The static initializer</td><td><img src="https://img.shields.io/badge/status-accepted%20rfc-informational" alt="accepted rfc" /></td></tr>
</tbody></table>
<h2 id="general-rules-for-input-vs-output"><a class="header" href="#general-rules-for-input-vs-output">General rules for &quot;input&quot; vs &quot;output&quot;</a></h2>
<p>In general, the role of <code>impl Trait</code> and <code>'_</code> both follow the same rules in terms of being &quot;input vs output&quot;.  When in an argument listing, that is an &quot;input&quot; role and they correspond to a fresh parameter in the innermost binder. Otherwise, they are in &quot;output&quot; role and the corresponding to something which is inferred or selected from context (in the case of <code>'_</code> in return position, it is selected based on the rules of lifetime elision; <code>'_</code> within a function body corresponds to inference).</p>
<h2 id="type-alias-impl-trait"><a class="header" href="#type-alias-impl-trait">Type alias impl trait</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Trait;
<span class="boring">}
</span></code></pre></pre>
<p>Creates a opaque type whose value will be inferred by the contents of the enclosing module (and its submodules).</p>
<h2 id="fn-argument-position"><a class="header" href="#fn-argument-position">Fn argument position</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: impl Trait)
<span class="boring">}
</span></code></pre></pre>
<p>becomes an &quot;anonymous&quot; generic parameter, analogous to</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Trait&gt;(x: T)
<span class="boring">}
</span></code></pre></pre>
<p>However, when <code>impl Trait</code> is used on a function, the resulting type parameter cannot be specified using &quot;turbofish&quot; form; its value must be inferred. (<strong>status:</strong> this detail not yet decided).</p>
<p>Places this can be used:</p>
<ul>
<li>Top-level functions and inherent methods</li>
<li>Trait methods
<ul>
<li>Implication: trait is not dyn safe</li>
</ul>
</li>
</ul>
<h2 id="fn-return-position"><a class="header" href="#fn-return-position">Fn return position</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; impl Trait)
<span class="boring">}
</span></code></pre></pre>
<p>becomes an &quot;anonymous&quot; generic parameter, analogous to</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Trait&gt;(x: T)

type Foo = impl Trait; // defining scope: just the fn
fn foo() -&gt; Foo
<span class="boring">}
</span></code></pre></pre>
<p>Places this can be used:</p>
<ul>
<li>Top-level functions and inherent methods</li>
<li>Trait methods (pending; no RFC)</li>
</ul>
<h2 id="let-bindings"><a class="header" href="#let-bindings">Let bindings</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x: impl Debug = ...;
}
<span class="boring">}
</span></code></pre></pre>
<p>becomes a type alias impl trait, analogous to</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Debug; // scope: fn body
fn foo() {
    let x: Foo = ...;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-where-can-impl-trait-not-be-used"><a class="header" href="#appendix-b-where-can-impl-trait-not-be-used">Appendix B: Where can impl trait NOT be used</a></h1>
<p>Where is impl Trait not (yet?) accepted and why.</p>
<h3 id="dyn-types-angle-brackets"><a class="header" href="#dyn-types-angle-brackets">dyn Types, angle brackets</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;mut dyn Iterator&lt;Item = impl Debug&gt;)
<span class="boring">}
</span></code></pre></pre>
<h3 id="dyn-types-parentheses"><a class="header" href="#dyn-types-parentheses">dyn Types, parentheses</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;mut dyn FnMut(impl Debug))
<span class="boring">}
</span></code></pre></pre>
<p>Unclear whether this should (eventually) be short for <code>dyn for&lt;T: Debug&gt; FnMut(T)</code> (which would not be legal) to stay analogous to <code>impl FnOnce(impl Debug)</code>.</p>
<h3 id="dyn-types-return-types"><a class="header" href="#dyn-types-return-types">dyn Types, return types</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;mut dyn FnMut() -&gt; impl Debug)
<span class="boring">}
</span></code></pre></pre>
<h3 id="nested-impl-trait-parentheses"><a class="header" href="#nested-impl-trait-parentheses">Nested impl trait, parentheses</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: impl FnMut(impl Debug))
<span class="boring">}
</span></code></pre></pre>
<p>Unclear whether this should (eventually) be short for <code>impl for&lt;T: Debug&gt; FnMut(T)</code> or some other notation.</p>
<h3 id="where-clauses-angle-brackets"><a class="header" href="#where-clauses-angle-brackets">Where clauses, angle brackets</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo()
where T: PartialEq&lt;impl Clone&gt;
<span class="boring">}
</span></code></pre></pre>
<h3 id="where-clauses-parentheses"><a class="header" href="#where-clauses-parentheses">Where clauses, parentheses</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo()
where T: FnOnce(impl Clone)
<span class="boring">}
</span></code></pre></pre>
<h3 id="where-clauses-return-position"><a class="header" href="#where-clauses-return-position">Where clauses, return position</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo()
where T: FnOnce() -&gt; impl Clone
<span class="boring">}
</span></code></pre></pre>
<h3 id="struct-fields"><a class="header" href="#struct-fields">Struct fields</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: impl Debug
}
<span class="boring">}
</span></code></pre></pre>
<p>It would be plausible to accept this as an &quot;output&quot; position, which also seems correct. The main reason that it is not accepted is that it has not been proposed, and there aren't a strong body of use cases. This is also the role that would be predicted from the &quot;general rule for input vs output&quot;.</p>
<p>It is not possible to accept this in <em>input</em> position, because that would imply that the type <code>Foo</code> has more generic parameters than are written on the type itself. Unlike with functions, where the values of those generic parameters can be inferred from the arguments, structs can appear in many contexts where inferring the values of those generic types would not be tractable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-glossary"><a class="header" href="#appendix-d-glossary">Appendix D: Glossary</a></h1>
<p>See the list of terms in the sidebar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-scope"><a class="header" href="#defining-scope">Defining scope</a></h1>
<p>The <strong>defining scope</strong> of an impl Trait is the code that is used to infer its <a href="explainer/glossary/./hidden_type.html">hidden type</a>. See the <a href="explainer/glossary/../tait_infer.html">explanation of type alias impl trait</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hidden-type"><a class="header" href="#hidden-type">Hidden type</a></h1>
<p>The <strong>hidden type</strong> of an impl Trait is the underlying type that the <code>impl Trait</code> represents. The compiler always infers the hidden type for an impl trait from the rest of the code. In some cases, there is just a single hidden type, but in other cases -- notably <a href="explainer/glossary/../apit.html">argument position impl trait</a> -- there can be multiple hidden types (e.g., one per call site).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rfc"><a class="header" href="#-rfc">‚ú® RFC</a></h1>
<blockquote>
<p>The RFC exists here in draft form. It will be edited and amended over the course of this initiative.
Note that some initiatives produce multiple RFCs.</p>
<p>Until there is an accepted RFC, any feature gates must be labeled as experimental.</p>
<p>When you're ready to start drafting, copy in the <a href="https://raw.githubusercontent.com/rust-lang/rfcs/master/0000-template.md">template text</a> from the <a href="https://github.com/rust-lang/rfcs">rfcs</a> repository.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-discussions"><a class="header" href="#design-discussions">Design discussions</a></h1>
<p>This directory hosts notes on important design discussions along with their resolutions.
In the table of contents, you will find the overall status:</p>
<ul>
<li>‚úÖ -- <strong>Settled!</strong> Input only needed if you have identified a fresh consideration that is not covered by the write-up.</li>
<li>üí¨ -- <strong>Under active discussion.</strong> Check the write-up, which may contain a list of questions or places where feedback is desired.</li>
<li>üí§ -- <strong>Paused.</strong> Not under active discussion, but we may be updating the write-up from time to time with details.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-frequently-asked-questions"><a class="header" href="#-frequently-asked-questions">üòï Frequently asked questions</a></h1>
<blockquote>
<p>This page lists frequently asked questions about the design. It often redirects to the other pages on the site.</p>
</blockquote>
<h2 id="what-is-the-goal-of-this-initiative"><a class="header" href="#what-is-the-goal-of-this-initiative">What is the goal of this initiative?</a></h2>
<p>See the <a href="./CHARTER.html">Charter</a>.</p>
<h2 id="who-is-working-on-it"><a class="header" href="#who-is-working-on-it">Who is working on it!</a></h2>
<p>See the <a href="./CHARTER.html">Charter</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
